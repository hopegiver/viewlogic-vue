/**
 * ViewLogic Authentication Management System
 * Ïù∏Ï¶ù Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú
 */
export class AuthManager {
    constructor(router, options = {}) {
        this.config = {
            enabled: options.authEnabled || false,
            loginRoute: options.loginRoute || 'login',
            protectedRoutes: options.protectedRoutes || [],
            protectedPrefixes: options.protectedPrefixes || [],
            publicRoutes: options.publicRoutes || ['login', 'register', 'home'],
            checkAuthFunction: options.checkAuthFunction || null,
            redirectAfterLogin: options.redirectAfterLogin || 'home',
            // Ïø†ÌÇ§/Ïä§ÌÜ†Î¶¨ÏßÄ ÏÑ§Ï†ï
            authCookieName: options.authCookieName || 'authToken',
            authFallbackCookieNames: options.authFallbackCookieNames || ['accessToken', 'token', 'jwt'],
            authStorage: options.authStorage || 'cookie',
            authCookieOptions: options.authCookieOptions || {},
            authSkipValidation: options.authSkipValidation || false,
            debug: options.debug || false
        };
        
        // ÎùºÏö∞ÌÑ∞ Ïù∏Ïä§ÌÑ¥Ïä§ Ï∞∏Ï°∞ (ÌïÑÏàò ÏùòÏ°¥ÏÑ±)
        this.router = router;
        
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑàÎì§
        this.eventListeners = new Map();
        
        this.log('AuthManager initialized', { enabled: this.config.enabled });
    }

    /**
     * ÎùºÏö∞Ìä∏ Ïù∏Ï¶ù ÌôïÏù∏
     */
    async checkAuthentication(routeName) {
        // Ïù∏Ï¶ù ÏãúÏä§ÌÖúÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêú Í≤ΩÏö∞
        if (!this.config.enabled) {
            return { allowed: true, reason: 'auth_disabled' };
        }

        this.log(`üîê Checking authentication for route: ${routeName}`);

        // Í≥µÍ∞ú ÎùºÏö∞Ìä∏Ïù∏ÏßÄ ÌôïÏù∏
        if (this.isPublicRoute(routeName)) {
            return { allowed: true, reason: 'public_route' };
        }

        // Î≥¥Ìò∏Îêú ÎùºÏö∞Ìä∏Ïù∏ÏßÄ ÌôïÏù∏
        const isProtected = this.isProtectedRoute(routeName);
        if (!isProtected) {
            return { allowed: true, reason: 'not_protected' };
        }

        // ÏÇ¨Ïö©Ïûê Ï†ïÏùò Ïù∏Ï¶ù Ï≤¥ÌÅ¨ Ìï®ÏàòÍ∞Ä ÏûàÎäî Í≤ΩÏö∞
        if (typeof this.config.checkAuthFunction === 'function') {
            try {
                const isAuthenticated = await this.config.checkAuthFunction(routeName);
                return {
                    allowed: isAuthenticated, 
                    reason: isAuthenticated ? 'custom_auth_success' : 'custom_auth_failed',
                    routeName
                };
            } catch (error) {
                this.log('Custom auth function failed:', error);
                return { allowed: false, reason: 'custom_auth_error', error };
            }
        }

        // Í∏∞Î≥∏ Ïù∏Ï¶ù ÌôïÏù∏
        const isAuthenticated = this.isUserAuthenticated();
        return {
            allowed: isAuthenticated, 
            reason: isAuthenticated ? 'authenticated' : 'not_authenticated',
            routeName
        };
    }

    /**
     * ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ù ÏÉÅÌÉú ÌôïÏù∏
     */
    isUserAuthenticated() {
        this.log('üîç Checking user authentication status');

        // 1. localStorage ÌôïÏù∏
        const token = localStorage.getItem('authToken') || localStorage.getItem('accessToken');
        if (token) {
            try {
                if (token.includes('.')) {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    if (payload.exp && Date.now() >= payload.exp * 1000) {
                        this.log('localStorage token expired, removing...');
                        localStorage.removeItem('authToken');
                        localStorage.removeItem('accessToken');
                        return false;
                    }
                }
                this.log('‚úÖ Valid token found in localStorage');
                return true;
            } catch (error) {
                this.log('Invalid token in localStorage:', error);
            }
        }

        // 2. sessionStorage ÌôïÏù∏
        const sessionToken = sessionStorage.getItem('authToken') || sessionStorage.getItem('accessToken');
        if (sessionToken) {
            this.log('‚úÖ Token found in sessionStorage');
            return true;
        }

        // 3. Ïø†ÌÇ§ ÌôïÏù∏
        const authCookie = this.getAuthCookie();
        if (authCookie) {
            try {
                if (authCookie.includes('.')) {
                    const payload = JSON.parse(atob(authCookie.split('.')[1]));
                    if (payload.exp && Date.now() >= payload.exp * 1000) {
                        this.log('Cookie token expired, removing...');
                        this.removeAuthCookie();
                        return false;
                    }
                }
                this.log('‚úÖ Valid token found in cookies');
                return true;
            } catch (error) {
                this.log('Cookie token validation failed:', error);
            }
        }

        // 4. Ï†ÑÏó≠ Î≥ÄÏàò ÌôïÏù∏ (Î†àÍ±∞Ïãú ÏßÄÏõê)
        if (window.user || window.isAuthenticated) {
            this.log('‚úÖ Global authentication variable found');
            return true;
        }

        this.log('‚ùå No valid authentication found');
        return false;
    }

    /**
     * Í≥µÍ∞ú ÎùºÏö∞Ìä∏Ïù∏ÏßÄ ÌôïÏù∏
     */
    isPublicRoute(routeName) {
        return this.config.publicRoutes.includes(routeName);
    }

    /**
     * Î≥¥Ìò∏Îêú ÎùºÏö∞Ìä∏Ïù∏ÏßÄ ÌôïÏù∏
     */
    isProtectedRoute(routeName) {
        // ÌäπÏ†ï ÎùºÏö∞Ìä∏Í∞Ä Î≥¥Ìò∏Îêú ÎùºÏö∞Ìä∏ Î™©Î°ùÏóê ÏûàÎäîÏßÄ ÌôïÏù∏
        if (this.config.protectedRoutes.includes(routeName)) {
            return true;
        }

        // prefixÎ°ú Î≥¥Ìò∏Îêú ÎùºÏö∞Ìä∏Ïù∏ÏßÄ ÌôïÏù∏
        for (const prefix of this.config.protectedPrefixes) {
            if (routeName.startsWith(prefix)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Ïù∏Ï¶ù Ïø†ÌÇ§ Í∞ÄÏ†∏Ïò§Í∏∞
     */
    getAuthCookie() {
        // Ï£º Ïø†ÌÇ§ Ïù¥Î¶Ñ ÌôïÏù∏
        const primaryCookie = this.getCookieValue(this.config.authCookieName);
        if (primaryCookie) {
            return primaryCookie;
        }

        // ÎåÄÏ≤¥ Ïø†ÌÇ§ Ïù¥Î¶ÑÎì§ ÌôïÏù∏
        for (const cookieName of this.config.authFallbackCookieNames) {
            const cookieValue = this.getCookieValue(cookieName);
            if (cookieValue) {
                this.log(`Found auth token in fallback cookie: ${cookieName}`);
                return cookieValue;
            }
        }

        return null;
    }

    /**
     * Ïø†ÌÇ§ Í∞í Í∞ÄÏ†∏Ïò§Í∏∞
     */
    getCookieValue(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) {
            return decodeURIComponent(parts.pop().split(';').shift());
        }
        return null;
    }

    /**
     * Ïù∏Ï¶ù Ïø†ÌÇ§ Ï†úÍ±∞
     */
    removeAuthCookie() {
        const cookiesToRemove = [this.config.authCookieName, ...this.config.authFallbackCookieNames];
        
        cookiesToRemove.forEach(cookieName => {
            // ÌòÑÏû¨ Í≤ΩÎ°úÏôÄ Î£®Ìä∏ Í≤ΩÎ°úÏóêÏÑú Î™®Îëê Ï†úÍ±∞
            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${window.location.pathname};`;
        });
        
        this.log('Auth cookies removed');
    }

    /**
     * Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ Í∞ÄÏ†∏Ïò§Í∏∞
     */
    getAccessToken() {
        // localStorage ÌôïÏù∏
        let token = localStorage.getItem('authToken') || localStorage.getItem('accessToken');
        if (token) return token;

        // sessionStorage ÌôïÏù∏
        token = sessionStorage.getItem('authToken') || sessionStorage.getItem('accessToken');
        if (token) return token;

        // Ïø†ÌÇ§ ÌôïÏù∏
        token = this.getAuthCookie();
        if (token) return token;

        return null;
    }

    /**
     * Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ ÏÑ§Ï†ï
     */
    setAccessToken(token, options = {}) {
        if (!token) {
            this.log('Empty token provided');
            return false;
        }

        const {
            storage = this.config.authStorage,
            cookieOptions = this.config.authCookieOptions,
            skipValidation = this.config.authSkipValidation
        } = options;

        try {
            // JWT ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù (ÏòµÏÖò)
            if (!skipValidation && token.includes('.')) {
                try {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    if (payload.exp && Date.now() >= payload.exp * 1000) {
                        this.log('‚ùå Token is expired');
                        return false;
                    }
                    this.log('‚úÖ JWT token validated');
                } catch (error) {
                    this.log('‚ö†Ô∏è JWT validation failed, but proceeding:', error.message);
                }
            }

            // Ïä§ÌÜ†Î¶¨ÏßÄÎ≥Ñ Ï†ÄÏû•
            switch (storage) {
                case 'localStorage':
                    localStorage.setItem('authToken', token);
                    this.log('Token saved to localStorage');
                    break;

                case 'sessionStorage':
                    sessionStorage.setItem('authToken', token);
                    this.log('Token saved to sessionStorage');
                    break;

                case 'cookie':
                    this.setAuthCookie(token, cookieOptions);
                    break;

                default:
                    // Í∏∞Î≥∏Í∞í: localStorage
                    localStorage.setItem('authToken', token);
                    this.log('Token saved to localStorage (default)');
            }

            this.emitAuthEvent('token_set', { 
                storage,
                tokenLength: token.length,
                hasExpiration: token.includes('.')
            });

            return true;

        } catch (error) {
            this.log('Failed to set token:', error);
            return false;
        }
    }

    /**
     * Ïù∏Ï¶ù Ïø†ÌÇ§ ÏÑ§Ï†ï
     */
    setAuthCookie(token, options = {}) {
        const {
            cookieName = this.config.authCookieName,
            secure = window.location.protocol === 'https:',
            sameSite = 'Strict',
            path = '/',
            domain = null
        } = options;

        let cookieString = `${cookieName}=${encodeURIComponent(token)}; path=${path}`;

        if (secure) {
            cookieString += '; Secure';
        }

        if (sameSite) {
            cookieString += `; SameSite=${sameSite}`;
        }

        if (domain) {
            cookieString += `; Domain=${domain}`;
        }

        // JWTÏóêÏÑú ÎßåÎ£å ÏãúÍ∞Ñ Ï∂îÏ∂ú
        try {
            if (token.includes('.')) {
                try {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    if (payload.exp) {
                        const expireDate = new Date(payload.exp * 1000);
                        cookieString += `; Expires=${expireDate.toUTCString()}`;
                    }
                } catch (error) {
                    this.log('Could not extract expiration from JWT token');
                }
            }
        } catch (error) {
            this.log('Token processing error:', error);
        }

        document.cookie = cookieString;
        this.log(`Auth cookie set: ${cookieName}`);
    }

    /**
     * ÌÜ†ÌÅ∞ Ï†úÍ±∞
     */
    removeAccessToken(storage = 'all') {
        switch (storage) {
            case 'localStorage':
                localStorage.removeItem('authToken');
                localStorage.removeItem('accessToken');
                break;

            case 'sessionStorage':
                sessionStorage.removeItem('authToken');
                sessionStorage.removeItem('accessToken');
                break;

            case 'cookie':
                this.removeAuthCookie();
                break;

            case 'all':
            default:
                localStorage.removeItem('authToken');
                localStorage.removeItem('accessToken');
                sessionStorage.removeItem('authToken');
                sessionStorage.removeItem('accessToken');
                this.removeAuthCookie();
                break;
        }

        this.emitAuthEvent('token_removed', { storage });
        this.log(`Token removed from: ${storage}`);
    }

    /**
     * Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ Ï≤òÎ¶¨
     */
    handleLoginSuccess(targetRoute = null) {
        const redirectRoute = targetRoute || this.config.redirectAfterLogin;
        
        this.log(`üéâ Login success, redirecting to: ${redirectRoute}`);
        
        this.emitAuthEvent('login_success', { targetRoute: redirectRoute });
        
        // ÎùºÏö∞ÌÑ∞ Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä ÏûàÏúºÎ©¥ ÏßÅÏ†ë ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò
        if (this.router && typeof this.router.navigateTo === 'function') {
            this.router.navigateTo(redirectRoute);
        }
        
        return redirectRoute;
    }

    /**
     * Î°úÍ∑∏ÏïÑÏõÉ Ï≤òÎ¶¨
     */
    handleLogout() {
        this.log('üëã Logging out user');
        
        // Î™®Îì† Ï†ÄÏû•ÏÜåÏóêÏÑú ÌÜ†ÌÅ∞ Ï†úÍ±∞
        this.removeAccessToken();
        
        // Ï†ÑÏó≠ Î≥ÄÏàò Ï†ïÎ¶¨
        if (window.user) window.user = null;
        if (window.isAuthenticated) window.isAuthenticated = false;
        
        this.emitAuthEvent('logout', {});
        
        // ÎùºÏö∞ÌÑ∞ Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä ÏûàÏúºÎ©¥ ÏßÅÏ†ë ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò
        if (this.router && typeof this.router.navigateTo === 'function') {
            this.router.navigateTo(this.config.loginRoute);
        }
        
        return this.config.loginRoute;
    }

    /**
     * Ïù∏Ï¶ù Ïù¥Î≤§Ìä∏ Î∞úÏÉù
     */
    emitAuthEvent(eventType, data) {
        const event = new CustomEvent('router:auth', {
            detail: {
                type: eventType,
                timestamp: Date.now(),
                ...data
            }
        });
        
        document.dispatchEvent(event);
        
        // ÎÇ¥Î∂Ä Î¶¨Ïä§ÎÑàÎì§ÏóêÍ≤åÎèÑ ÏïåÎ¶º
        if (this.eventListeners.has(eventType)) {
            this.eventListeners.get(eventType).forEach(listener => {
                try {
                    listener(data);
                } catch (error) {
                    this.log('Event listener error:', error);
                }
            });
        }
        
        this.log(`üîî Auth event emitted: ${eventType}`, data);
    }

    /**
     * Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
     */
    on(eventType, listener) {
        if (!this.eventListeners.has(eventType)) {
            this.eventListeners.set(eventType, []);
        }
        this.eventListeners.get(eventType).push(listener);
    }

    /**
     * Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†úÍ±∞
     */
    off(eventType, listener) {
        if (this.eventListeners.has(eventType)) {
            const listeners = this.eventListeners.get(eventType);
            const index = listeners.indexOf(listener);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        }
    }

    /**
     * Ïù∏Ï¶ù ÏÉÅÌÉú ÌÜµÍ≥Ñ
     */
    getAuthStats() {
        return {
            enabled: this.config.enabled,
            isAuthenticated: this.isUserAuthenticated(),
            hasToken: !!this.getAccessToken(),
            protectedRoutesCount: this.config.protectedRoutes.length,
            protectedPrefixesCount: this.config.protectedPrefixes.length,
            publicRoutesCount: this.config.publicRoutes.length,
            storage: this.config.authStorage,
            loginRoute: this.config.loginRoute
        };
    }

    /**
     * ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏
     */
    updateConfig(newConfig) {
        const oldEnabled = this.config.enabled;
        this.config = { ...this.config, ...newConfig };
        
        if (oldEnabled !== this.config.enabled) {
            this.log(`Auth system ${this.config.enabled ? 'enabled' : 'disabled'}`);
        }
        
        this.log('Auth config updated', this.config);
    }

    /**
     * ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏
     */
    log(...args) {
        if (this.config.debug) {
            console.log('[AuthManager]', ...args);
        }
    }

    /**
     * Ï†ïÎ¶¨ (Î©îÎ™®Î¶¨ ÎàÑÏàò Î∞©ÏßÄ)
     */
    destroy() {
        this.eventListeners.clear();
        this.log('AuthManager destroyed');
    }
}